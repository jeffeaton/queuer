% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bulk.R
\name{qlapply}
\alias{enqueue_bulk}
\alias{qlapply}
\title{Run tasks in a queue}
\usage{
qlapply(X, FUN, obj, ..., envir = parent.frame(), timeout = Inf,
  time_poll = 1, progress_bar = TRUE)

enqueue_bulk(obj, X, FUN, ..., do.call = FALSE, timeout = Inf,
  time_poll = 1, progress_bar = TRUE, envir = parent.frame())
}
\arguments{
\item{X}{A vector (atomic or list) to evaluate \code{FUN} on each
element of.}

\item{FUN}{A function.  This can be a function specified by value
(e.g. \code{sin}) or by name (e.g. \code{"sin"}).  Some effort
is made to determine that the function can be found in the
environment that the queue itself uses.}

\item{obj}{The queue object.}

\item{...}{Additional arguments to pass through to \code{FUN}
along with each element of \code{X}.}

\item{envir}{Environment to search for functions in.  This might change.}

\item{timeout}{Time to wait for tasks to be returned.  The default
is to wait forever.  If \code{0} (or a negative value) is given
then \code{qlapply} will not block but will instead return a
\code{task_bundle} object which can be used to inspect the
task status.}

\item{time_poll}{How often to check for task completion.  The
default is every second.  This is an \emph{approximate} time and
should be seen as a lower limit.}

\item{progress_bar}{Display a progress bar as tasks are polled.}

\item{do.call}{If \code{TRUE}, rather than evaluating \code{FUN(x,
...)}, evaluate \code{FUN(x[1], x[2], ..., x[n], ...)} (where
\code{x} is an element of \code{X}).}
}
\description{
A queued version of \code{\link{lapply}}.  With this, tasks are
sent to a queue (specified by \code{obj}) and run in any order,
without communication between tasks.  The functions
\code{enqueue_bulk} function is a slightly different inteface that
allows looping over rows in a data.frame as if they are parameters
to a function.
}
\details{
If the function is interrupted after all tasks have been submitted
(the progress bar will be displayed at this point) then
interrupting the process (e.g. with Ctrl-C) will return a
\code{task_bundle} object that can be queried.  Otherwise if the
timeout is reached an error will be thrown.  In either case the
tasks will continue on the cluster.
}

